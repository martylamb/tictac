package tictac;

import tictac.Tokenizer.Token;
import tictac.Tokenizer.TokenType;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.LineNumberReader;
import java.io.PrintWriter;
import java.util.LinkedList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 *
 * @author mlamb
 */
public class Compiler {
    
    private final File src, dest;
    private final String className;
    private final Tokenizer tokenizer;
    private final List<Token> fileScope;
    private final LinkedList<Template> templates;
    private boolean needsEscapeMethod = false;
    
    private final Pattern fileScopePattern = Pattern.compile("^\\s*(?:import|package)\\s.*$");
    private final Pattern templatePattern = Pattern.compile("^\\s*(?:template)\\s+(.*)$");

    private static final String DEFAULT_EXTENSION = ".tic";
    private static final String DEFAULT_TEMPLATE = "defaultText()"; // name used for undeclared template
    private static final String OUT = "_tictacOut"; // name of stringbuilder used by templates
    private static final String ESCAPE = "_tictacEscape"; // name of escape method
    
    public static void compile(File src) throws IOException {
        if (src.isDirectory()) compile(src, src);
        else compile(src, src.getParentFile());
    }
    
    public static void compile(File src, File destDir) throws IOException {
        if (!src.exists()) throw new FileNotFoundException(src.getAbsolutePath());
        if (src.isDirectory()) {
            destDir.mkdirs();
            for (File f : src.listFiles()) {
                if (f.isDirectory()) compile(f, new File(destDir, f.getName()));
                else if (f.getName().toLowerCase().endsWith(DEFAULT_EXTENSION)) compile(f, destDir);
            }
        } else {
            new Compiler(src, destDir).compile();
        }
    }
    
    private Compiler(File src, File destDir) {
        this.src = src;
        className = dropExtension(src.getName());
        dest = new File(destDir, this.className + ".java");
        tokenizer = new Tokenizer();
        fileScope = new java.util.LinkedList<>();
        templates = new java.util.LinkedList<>();
        templates.add(new Template(null));
    }
    
    private void compile() throws IOException {
        System.out.format("twc: %s\n", src.getAbsolutePath());
        System.out.format("  => %s\n", dest.getAbsolutePath());
        LineNumberReader lin = new LineNumberReader(new FileReader(src));
        String line;
        while ((line = lin.readLine()) != null) processLine(line);
        
        dest.getParentFile().mkdirs();
        PrintWriter pout = new PrintWriter(new FileWriter(dest));
        output(pout);
        pout.close();
    }
    
    private void processLine(String line) {
        tokenizer.reset(line);
        boolean anyOutput = false;
        boolean anyTokens = false;
        for (Token t : tokenizer) {
            if (t.isEmpty()) continue;
            anyTokens = true;
            if (t.type == TokenType.JAVA) {
                processJavaToken(t);
            } else {
                templates.getLast().add(t);
                anyOutput = true;
            }            
        }
        if (anyOutput || !anyTokens) templates.getLast().add(tokenizer.eol());
    }

    private void processJavaToken(Token t) {
        if (fileScopePattern.matcher(t.body).matches()) {
            fileScope.add(t);
        } else {
            Matcher m = templatePattern.matcher(t.body);
            if (m.matches()) templates.add(new Template(m.group(1)));
            else templates.getLast().add(t);
        }
    }

    private void output(PrintWriter out) throws IOException {
        out.format("// Automatically generated - DO NOT EDIT!!!\n");
        out.format("// Generated by templatesWithClass %s\n", new java.util.Date());        
        for (Token t : fileScope) out.format("%s  %s\n", t.body.trim(), t.comment());
        out.format("\npublic class %s {\n", className);        
        for (Template t : templates) output(out, t);
        if (needsEscapeMethod) out.print(CompilerHelper.escapeMethod());
        out.format("\n}\n");
    }

    private void output(PrintWriter out, Template template) {
        if (skipTemplate(template)) return;
        
        out.format("\n\tpublic static String %s {\n", template.name == null ? DEFAULT_TEMPLATE : template.name);
        out.format("\t\tStringBuilder %s = new StringBuilder();\n", OUT);
        for (Token t : template) {
            switch(t.type) {
                case RAW:
                    out.format("\t\t%s.append(\"%s\"); %s\n", OUT, safeString(t.body), t.comment());
                    break;
                case ESCAPED:
                    out.format("\t\t%s.append(%s(%s));  %s\n", OUT, ESCAPE, t.body.trim(), t.comment());
                    needsEscapeMethod = true;
                    break;
                case UNESCAPED:
                    out.format("\t\t%s.append(%s);  %s\n", OUT, t.body.trim(), t.comment());
                    break;
                case JAVA:
                    out.format("\t\t%s  %s\n", t.body, t.comment());
                    break;
                default: throw new RuntimeException("Unexpected token type: " + t.type);
            }
        }
        out.format("\t\treturn %s.toString();\n", OUT);
        out.format("\t}\n");
    }
    
    private String safeString(String s) {
        if ("\n".equals(s)) return "\\n";
        return s.replaceAll("\\\\", Matcher.quoteReplacement("\\\\"))
            .replaceAll("\"", Matcher.quoteReplacement("\\\""))
            .replaceAll("\t", Matcher.quoteReplacement("\\t"));
    }
    
    private boolean skipTemplate(Template t) {
        // we don't output a default (undeclared) template if it only consists of whitespace
        if (t.name == null) {
            for (Token tok : t) {
                if (tok.type == TokenType.RAW) {
                    if (tok.body.trim().length() != 0 && !"\\n".equals(tok.body)) return false;
                } else return false;
            }
            return true;
        }
        return false;
    }
    
    private String dropExtension(String filename) {
        int pos = filename.lastIndexOf(".");
        return pos <= 0 ? filename : filename.substring(0, pos);
    }
        
    private class Template extends java.util.LinkedList<Token> {
        public final String name;
        public Template(String name) { this.name = name; }
    }
    
    private static void usage() {
        System.err.format("Usage: java %s SRCFILE|SRCDIR [DESTDIR]\n", Compiler.class.getCanonicalName());
        System.exit(2); // TODO magic number
    }
    
    public static void main(String[] args) throws Exception {
        switch (args.length) {
            case 1: compile(new File(args[0])); break;
            case 2: compile(new File(args[0]), new File(args[1])); break;
            default: usage();
        }
    }
}
